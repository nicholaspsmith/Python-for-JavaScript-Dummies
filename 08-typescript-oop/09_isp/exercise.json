{
  "title": "Interface Segregation Principle",
  "instructions": "Apply ISP: Clients should not be forced to depend on interfaces they don't use.\n\nProblem: A fat 'Worker' interface forces all implementations to have methods they don't need.\n\n1. Instead of one fat interface, create segregated interfaces:\n\n   Workable interface:\n   - work(): void\n\n   Eatable interface:\n   - eat(): void\n\n   Sleepable interface:\n   - sleep(): void\n\n2. Create these worker types:\n\n   Human class implements Workable, Eatable, Sleepable:\n   - constructor(name: string)\n   - work() logs '{name} is working'\n   - eat() logs '{name} is eating lunch'\n   - sleep() logs '{name} is sleeping'\n\n   Robot class implements Workable only:\n   - constructor(model: string)\n   - work() logs 'Robot {model} is working'\n   - (No eat or sleep - robots don't need them!)\n\n3. Create manager functions that use only what they need:\n   - assignWork(worker: Workable): void\n   - scheduleLunch(eater: Eatable): void\n   - endDay(sleeper: Sleepable): void\n\nKey insight: Robot doesn't need to implement empty eat() and sleep() methods. Each function depends only on what it needs."
}
