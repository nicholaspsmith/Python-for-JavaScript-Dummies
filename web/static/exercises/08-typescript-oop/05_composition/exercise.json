{
  "title": "Composition Over Inheritance",
  "instructions": "Learn to favor composition over inheritance for flexible designs.\n\nScenario: Build a notification system where users can have different notification preferences.\n\n1. Create notification channel interfaces:\n   - EmailChannel: send(message: string, email: string): void\n   - SMSChannel: send(message: string, phone: string): void\n   - PushChannel: send(message: string, deviceId: string): void\n\n2. Create channel implementations:\n   - EmailNotifier implements EmailChannel\n   - SMSNotifier implements SMSChannel  \n   - PushNotifier implements PushChannel\n   (Each logs 'Sending via {channel}: {message} to {destination}')\n\n3. Create a User class that composes these channels:\n   - private name: string\n   - private email?: string\n   - private phone?: string\n   - private deviceId?: string\n   - private emailChannel?: EmailChannel\n   - private smsChannel?: SMSChannel\n   - private pushChannel?: PushChannel\n\n4. Add methods to User:\n   - setEmailChannel(channel: EmailChannel, email: string)\n   - setSMSChannel(channel: SMSChannel, phone: string)\n   - setPushChannel(channel: PushChannel, deviceId: string)\n   - notify(message: string) - sends to all configured channels\n\nKey insight: Composition allows adding/removing capabilities at runtime without inheritance hierarchies."
}
