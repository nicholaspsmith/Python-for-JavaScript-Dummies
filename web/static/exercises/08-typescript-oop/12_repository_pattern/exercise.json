{
  "title": "Repository Pattern",
  "instructions": "Implement the Repository Pattern for data access abstraction.\n\nScenario: Build a product management system with swappable data stores.\n\n1. Create a Product interface:\n   - id: string\n   - name: string\n   - price: number\n   - category: string\n\n2. Create a Repository<T> generic interface:\n   - findById(id: string): T | undefined\n   - findAll(): T[]\n   - save(item: T): void\n   - delete(id: string): boolean\n   - findBy(predicate: (item: T) => boolean): T[]\n\n3. Create an InMemoryProductRepository implementing Repository<Product>:\n   - private products: Map<string, Product>\n   - Implement all Repository methods\n\n4. Create a ProductService class (uses the repository):\n   - constructor(private repository: Repository<Product>)\n   - getProduct(id: string): Product | undefined\n   - getAllProducts(): Product[]\n   - createProduct(product: Product): void\n   - deleteProduct(id: string): boolean\n   - getProductsByCategory(category: string): Product[]\n   - getExpensiveProducts(minPrice: number): Product[]\n\nKey insight: ProductService works with any Repository implementation. You could swap InMemoryProductRepository for a DatabaseProductRepository without changing ProductService."
}
