{
  "title": "Dependency Inversion Principle",
  "instructions": "Apply DIP: Depend on abstractions, not concretions.\n\nScenario: Build a notification system where high-level modules don't depend on low-level modules.\n\n1. Create abstractions (interfaces):\n\n   MessageFormatter interface:\n   - format(message: string): string\n\n   NotificationSender interface:\n   - send(formattedMessage: string): void\n\n   Logger interface:\n   - log(message: string): void\n\n2. Create implementations (low-level modules):\n\n   HTMLFormatter implements MessageFormatter:\n   - format returns '<div>{message}</div>'\n\n   PlainTextFormatter implements MessageFormatter:\n   - format returns message unchanged\n\n   EmailSender implements NotificationSender:\n   - send logs 'Sending email: {message}'\n\n   SMSSender implements NotificationSender:\n   - send logs 'Sending SMS: {message}'\n\n   ConsoleLogger implements Logger:\n   - log uses console.log with '[LOG]' prefix\n\n3. Create the high-level module:\n\n   NotificationService class:\n   - constructor(formatter: MessageFormatter, sender: NotificationSender, logger: Logger)\n   - notify(message: string): void - formats, sends, and logs\n\nKey insight: NotificationService depends on abstractions. We can swap implementations without changing NotificationService."
}
